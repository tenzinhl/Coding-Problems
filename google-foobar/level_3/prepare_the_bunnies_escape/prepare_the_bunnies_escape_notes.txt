What is the issue?

I'm failing a hidden verification test case online. Unclear where the issue is emerging

Guesses as to what the issue is:

# Guess 1: My pruning is over-eager/errored and is pruning out potential results
- Haven't been able to find a test case that does this

# Guess 2: My solution is timing out
- Seems highly unlikely. But it might just be it as the others don't seem to be it.
- In which case I should look into more pruning?
  - Is it possible that running it 400 times is too bad? Do I need to use the wall removal
    as one of the moves?
  - Argh, idk how I didn't think of this, but you can just BFS here, idk why I'm trying to backtrack

# Guess 3: My solution isn't finding the optimal solution in one case
- Maybe? What are some good test cases for this?

# Guess 4: Solution is incorrectly counting steps in certain situations
- I just don't see how. I mean at a high level this must be correct, but we're incrementing
  distance with each step so I just don't know.

# Guess 5: Finding a false solution that shouldn't be possible
  - Skipping squares?
  - Improperly checking if square is blocked by wall?
  - Improperly remarking walls?

@ Approaches for solving:
- Testing
  Just write some test cases. Start small. Test for the above 4 guesses and some extra random cases

- Code review
  Keep thinking about the reasons and check the code for errors. Low priority imo

Argh... can't figure it out tonight. Will have to try some other time.

In the future another thing to consider when there's this much time is if overall approach is wrong (in this
case I don't think it is, but rather if overall approach can be changed)

# BFS Attempt
Okay... nvm, I don't really know what I'm doing which sucks. I need to work soon too! BFS doesn't quite
make sense the way I'm imagining it. Maybe the correct way is with a two phase BFS? First you exhaust
all non wall-break possibilities, then use the walls found as potential starting points for the wall break
BFS?. That should only be O(mn) for time complexity still which is nice.

With the two stage I'd need to use Dijkstra's because the second stage would need to be prioritized

# Can I just try a BFS which removes each of the walls once?

# Theory: solution "Time limit" is based on logical time and not physical time. As in it counts the number
# of operations you do somehow and then whether you pass or fail is based on that! That would explain why
# even though my BFS and Backtracking solutions are wicked fast, they fail test cases. Particularly the
# confusing point was that the BFS solution despite being faster and getting the right answer for the same
# test cases it was still failing all test cases.

Oh what! I think I found a broken testcase that I just wasn't asserting aaahhh... nvm... it was because
the test case's value was being overridden later because I'm an idiot.

Yeah in this situation it seems like logical time is the key. Somehow they are tracking time complexity
through number of instructions. So if that's the theory then I need to use the advanced double BFS.

The idea here is to view the map as a 3D space (this technique can be expanded to multiple levels or in
the context of this problem multiple wall breaks). Each 2D layer represents the map. The map is then
duplicated once for each level of wall breaking, you can imagine them stacked on top of each other.

We can BFS through the 3D space, we still want to go from smallest path size to largest and BFS accomplishes
that. Whenever there's a wall taking that move is like a hole in the floor, you drop to the level below.

If there are no more levels below that path disappears as an option. (A wall that wasn't broken)
